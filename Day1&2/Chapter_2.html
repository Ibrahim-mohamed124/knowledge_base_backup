<!--
title: Backup, Restore, and Migration.
description: 
published: true
date: 2025-11-07T08:53:20.916Z
tags: 
editor: ckeditor
dateCreated: 2025-11-07T08:07:57.224Z
-->

<h1>Chapter&nbsp;2.&nbsp; Backup, Restore, and Migration of Applications with OADP</h1>
<ul>
  <li>To restore an application fully in k8s the following objects must be backed up:<ul>
      <li>Kubernetes <mark class="marker-yellow">resources</mark> that define the application and its settings.</li>
      <li><mark class="marker-yellow">Container images </mark>in the internal registry that containers of this application use.</li>
      <li><mark class="marker-yellow">Data</mark> that is stored in persistent volumes or object storage for a stateful application.</li>
    </ul>
  </li>
</ul>
<h3>Backing Up Application Resources</h3>
<ul>
  <li>Backing up an entire application involves:<ul>
      <li>Listing all the application resources</li>
      <li>Exporting the application resources</li>
      <li>Cleaning the application resources</li>
      <li>Deploying the cleaned resources</li>
    </ul>
  </li>
</ul>
<blockquote>
  <p>yq utility is very useful to clean unwanted attributes from a yaml file</p>
</blockquote>
<h3>Backing Up Container Images</h3>
<ul>
  <li>Podman and Skopeo</li>
  <li>To access the registry from outside the cluster or to export images from your local machine, an OpenShift administrator must expose the registry externally.</li>
</ul>
<pre><code class="language-plaintext">oc patch \
  configs.imageregistry.operator.openshift.io/cluster \
  --patch '{"spec":{"defaultRoute":true}}' \
  --type merge</code></pre>
<p>&nbsp;</p>
<blockquote>
  <p>The modification to the image registry operator triggers a redeployment of the OpenShift API server. It can take up to 10 minutes for the cluster to stabilize.</p>
</blockquote>
<ul>
  <li>The operator creates a <code>default-route</code> route to expose externally the registry that uses the following URL format:</li>
</ul>
<pre><code class="language-plaintext">default-route-openshift-image-registry.apps-domain</code></pre>
<p>&nbsp;</p>
<pre><code class="language-plaintext"> REGISTRY=$(oc get \
  route default-route \
  -n openshift-image-registry \
  --template '{{.spec.host}}')</code></pre>
<p>&nbsp;</p>
<ul>
  <li>OpenShift users who do not have access to the <code>openshift-image-registry</code> namespace can retrieve the registry URL from any image stream:</li>
</ul>
<pre><code class="language-plaintext">oc -n openshift get is/cli \
  -ojsonpath="{.status.publicDockerImageRepository}{'\n'}"
</code></pre>
<ul>
  <li>You can then log in to the internal registry by using your OpenShift username and authentication token with the following command:</li>
</ul>
<pre><code class="language-plaintext">podman login \
  -u $(oc whoami) \
  -p $(oc whoami -t) \
  --tls-verify=false \
  $REGISTRY</code></pre>
<p>&nbsp;</p>
<ul>
  <li>The <code>oc registry login</code> command automatically uses your authentication token and the internal registry URL from the OpenShift cluster.</li>
  <li>The <code>oc</code> command stores the credentials in the <code>${HOME}/.docker/config.json</code> file in Base64 format. The Podman, Skopeo, and Docker clients can use the authentication details from that file to access an image registry.</li>
</ul>
<pre><code class="language-plaintext">oc registry login</code></pre>
<h4>Export Container Images</h4>
<pre><code class="language-plaintext">skopeo copy \
  docker://${REGISTRY}/project_name/imagestream:tag \ 1
  docker://remote-registry.example.com/path/to/image:remotetag 2
  
1. Fully qualified source image in the OpenShift internal registry &gt;&gt; exposed externally to export
images from outside the cluster

2. Destination registry URL with image and tag information</code></pre>
<blockquote>
  <p>Skopeo can copy images to other locations such as a local directory or a <code>.tar</code> archive.</p>
</blockquote>
<p>or</p>
<pre><code class="language-plaintext">podman pull ${REGISTRY}/project_name/imagestream:tag

podman save ${REGISTRY}/project_name/imagestream:tag \
  | bzip2 &gt; image_backup.tar.bz2</code></pre>
<p>or</p>
<pre><code class="language-plaintext">oc image mirror ${REGISTRY}/project_name/imagestream:* \ 1
  remote-registry.example.com/path/to/image
  
1. You can use the wildcard character (*) to copy all the tags to the destination registry.

</code></pre>
<p>&nbsp;</p>
<ul>
  <li>To export a container image from within the cluster, you can use any available container tools in a pod to copy the image to the location of your choice, such as a persistent volume on NFS storage, S3 storage, or a remote registry.</li>
</ul>
<pre><code class="language-plaintext">apiVersion: batch/v1
kind: Job
metadata:
  name: backup-image
  namespace: application
  labels:
    app: backup
spec:
  backoffLimit: 1
  template:
    metadata:
      labels:
        app: backup
    spec:
      containers:
      - name: backup
        image: image-registry.openshift-image-registry.svc:5000/openshift/cli:latest
        env:
        - name: REGISTRY_AUTH_FILE
          value: /tmp/dockercfg.json
        command: ["/bin/bash", "-c"]
        args:
        - | 1
          oc registry login
          oc image mirror \
            image-registry.openshift-image-registry.svc:5000/application/myapp:* \
            file://myapp --dir /backup
        volumeMounts: 2
          - mountPath: /backup
            name: backup
      ...output omitted...
      volumes: 3
      - name: backup
        persistentVolumeClaim:
          claimName: backup-volume
          
1. Log in to the internal registry and export all tags of the myapp image stream to the /backup path.

2. Volume mount definition for the backup location.

3. Volume definition for the backup persistent volume claims (PVC).</code></pre>
<ul>
  <li>You need the <code>system:image-puller</code> role on the OpenShift project to pull images from any image streams in that project. Project users and administrators already have this permission, as well as the <code>default</code> service account.</li>
</ul>
<h4>Import Container Images</h4>
<pre><code class="language-plaintext">skopeo copy \
  docker://remote-registry.example.com/myimage:latest \
  docker://${REGISTRY}/project_name/mynewimagestream:latest</code></pre>
<p>&nbsp;</p>
<p>or</p>
<pre><code class="language-plaintext"> oc image mirror \
  remote-registry.example.com/myimage:latest \
  ${REGISTRY}/project_name/mynewimagestream:latest</code></pre>
<p>&nbsp;</p>
<p>or</p>
<pre><code class="language-plaintext">podman load -i image_backup.tar.bz2

podman tag \
  registry.apps.ocp4.example.com/application/myapp:1.2.3 \
  ${REGISTRY}/newproject/myapp:1.2.3
  
podman push ${REGISTRY}/newproject/myapp:1.2.3</code></pre>
<blockquote>
  <p>You need the <code>system:image-pusher</code> role on the OpenShift project to push images to any image streams in that project. Project users and administrators already have this permission, as well as the <code>builder</code> service account.</p>
</blockquote>
<h3>Backing Up Application Data</h3>
<ul>
  <li>Different consistency levels can be achieved depending on the backup method.<ul>
      <li><strong>Inconsistent backup</strong>
        <ul>
          <li>A backup is called inconsistent when the<mark class="marker-yellow"> application alters data during the backup process</mark>. Traditional data copying when the application is running creates inconsistent backups.</li>
        </ul>
      </li>
      <li><strong>Crash-consistent backup</strong>
        <ul>
          <li>A crash-consistent backup is created by suspending disk I/O during the backup, either by using snapshot technology or specialized tools, to ensure data consistency on disk. <mark class="marker-yellow">Application data in memory or pending I/O operations are not captured.</mark> The state of the application is kept as if the application was suddenly shut down due to power loss, or crashed.</li>
        </ul>
      </li>
      <li><strong>Application-consistent backup</strong>
        <ul>
          <li>Application-consistent backup is the most reliable type of backup because it <mark class="marker-yellow">ensures that all in-memory data and pending I/O operations are written on disk before creating the backup</mark>.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Some applications provide a set of tools to flush memory data to disk and to pause file system operations on demand. These tools provide an application-consistent backup without any downtime by using snapshots, and is also known as<mark class="marker-yellow"> </mark><i><mark class="marker-yellow">hot backup</mark></i><mark class="marker-yellow">.</mark></li>
  <li>A more universal way to create application-consistent backup is to stop the application, copy the data to another location, and then restart the application. This method is also called<mark class="marker-yellow"> </mark><i><mark class="marker-yellow">cold backup</mark></i><mark class="marker-yellow">,</mark> because the application is down during the operation.</li>
  <li>These pervious methods can halt the application for long time, so a better approach is to use volume snapshots. CSI takes a snapshot of certain volume and the backup can be created from the cloned volume without any effect on the application performance.</li>
</ul>
<h4>Volume Snapshot</h4>
<ul>
  <li>Container Storage Interface (CSI) drivers that support volume snapshots:</li>
</ul>
<figure class="table">
  <table style="background-color:rgb(255, 255, 255);">
    <thead>
      <tr>
        <th style="padding:5px;vertical-align:top;"><strong>Storage provider</strong></th>
        <th style="padding:5px;vertical-align:top;"><strong>CSI driver</strong></th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td style="padding:5px;vertical-align:top;">AWS Elastic Block Storage</td>
        <td style="padding:5px;vertical-align:top;"><code>efs.csi.aws.com</code></td>
      </tr>
      <tr>
        <td style="padding:5px;vertical-align:top;">Azure Disk</td>
        <td style="padding:5px;vertical-align:top;"><code>disk.csi.azure.com</code></td>
      </tr>
      <tr>
        <td style="padding:5px;vertical-align:top;">CephFS</td>
        <td style="padding:5px;vertical-align:top;"><code>cephfs.csi.ceph.com</code></td>
      </tr>
      <tr>
        <td style="padding:5px;vertical-align:top;">Ceph RBD</td>
        <td style="padding:5px;vertical-align:top;"><code>rbd.csi.ceph.com</code></td>
      </tr>
      <tr>
        <td style="padding:5px;vertical-align:top;">NetApp</td>
        <td style="padding:5px;vertical-align:top;"><code>csi.trident.netapp.i</code></td>
      </tr>
    </tbody>
  </table>
</figure>
<ul>
  <li><strong>VolumeSnapshotClass:</strong>
    <ul>
      <li>a volume snapshot class describes the CSI driver and associated settings to create a volume snapshot.</li>
      <li>The <code>VolumeSnapshotClass</code> driver must match the <code>StorageClass</code> provisioner of the source PVC.</li>
    </ul>
  </li>
</ul>
<pre><code class="language-plaintext">oc get volumesnapshotclasses

apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshotClass
metadata:
  name: csi-hostpath-snapclass
driver: hostpath.csi.k8s.io
deletionPolicy: Delete
parameters:</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
